### 📌 한줄 정리

명령어 사이클은 CPU가 하나의 명령어를 실행하는 과정(인출 → 해독 → 실행 → 저장)이고, 파이프라이닝은 이 단계를 겹쳐서 동시에 처리하여 CPU 성능을 높이는 기술이다.

---

### 명령어 사이클

프로그램 속 각각의 명령어들이 반복되어 실행되는 일정한 주기이다.

- **인출 사이클(Fetch Cycle)**: 메모리에서 명령어를 가져온다. (PC → MAR → MBR → IR)
- **해독(Decode)**: 제어장치(CU)가 명령어를 해석한다.
- **실행 사이클(Execute Cycle)**: 제어장치가 명령어 레지스터의 값을 해석하고 제어 신호를 발생시키면, ALU가 연산을 수행한다.
- **저장(Store)**: 실행 결과를 레지스터 또는 메모리에 저장한다.
- **간접 사이클(Indirect Cycle)**: 명령어 실행을 위해 메모리 접근이 추가로 필요한 경우 실행되는 단계이다.

---

### 파이프라이닝 (Pipelining)

명령어를 여러 단계로 분리해, 여러 명령어를 겹쳐서 동시에 실행하는 방식이다. 명령어 하나를 처리하는 시간(Latency)은 줄어들지 않지만, 일정 시간 동안 처리하는 명령어의 총개수(Throughput, 처리량)는 극적으로 향상된다.

- **예시**: 명령어1이 '실행' 단계에 있을 때, 명령어2는 '해독' 단계, 명령어3은 '인출' 단계를 동시에 수행하는 것이 가능하다.
- **장점**: 처리량(Throughput)이 증가하고 CPU 활용도가 향상된다.
- **문제점 (Hazard)**: 데이터, 제어, 구조적 문제가 발생할 수 있다.

---

### 파이프라인 해저드 해결 방안

### 1. 데이터 해저드 (Data Hazard)

- **정의**: 이전 명령의 수행 결과가 다음 명령의 수행에 필요할 때, 데이터 의존성으로 인해 발생하는 문제이다.
- **예시**:코드 스니펫
    
    # 
    
    `ADD R1, R2, R3  ; R2와 R3를 더해서 R1에 저장
    SUB R4, R1, R5  ; R1에서 R5를 빼서 R4에 저장`
    
    `SUB` 명령어는 `ADD` 명령어가 R1에 값을 저장해야만 실행될 수 있다. 하지만 파이프라인에서는 `ADD`가 결과를 저장하기 전에 `SUB`가 R1 값을 읽으려고 시도하기 때문에 문제가 생긴다.
    
- **해결책**:
    - **전방전달 (Forwarding / Bypassing)**: `ADD`의 연산 결과가 저장 단계까지 가지 않고, 실행 단계(ALU)에서 끝나자마자 그 결과물을 `SUB` 명령어의 실행 단계 입력으로 직접 전달하는 기술이다.
    - **파이프라인 지연 (Stall / Bubble)**: 전방전달로 해결되지 않을 경우, 문제가 되는 명령어의 실행을 잠시 지연시키고 파이프라인에 빈 공간(버블)을 삽입하여 시간차를 둔다.

### 2. 제어 해저드 (Control Hazard)

- **정의**: 분기(Branch) 명령어와 같은 프로그램의 실행 흐름 변경으로 인해, 다음에 실행할 명령어를 미리 알 수 없어 발생하는 문제이다.
- **예시**:코드 스니펫
    
    # 
    
    `BEQ R1, R2, L1 ; R1과 R2가 같다면 L1 주소로 점프
    ADD R3, R4, R5 ; (점프 여부가 결정되기 전에 이 명령어가 인출됨)`
    
    `BEQ` 명령어의 분기 여부가 결정되기 전에, 파이프라인은 순차적으로 다음 명령어인 `ADD`를 이미 인출하여 처리하고 있다. 만약 분기가 발생하면, 이미 처리 중인 `ADD`는 쓸모없는 명령이 되어 파이프라인을 비워야 한다.
    
- **해결책**:
    - **분기 예측 (Branch Prediction)**: 분기 명령어의 결과를 미리 예측하여, 예측된 주소의 명령어를 실행하는 것이다. 예측이 성공하면 지연 없이 성능이 향상되지만, 예측이 틀리면 파이프라인에 들어온 잘못된 명령어들을 모두 비우고(Flush) 올바른 주소부터 다시 시작해야 한다. 이는 현대 CPU의 성능을 좌우하는 매우 중요한 기술이다.

### 3. 구조 해저드 (Structural Hazard)

- **정의**: 여러 명령어가 파이프라인의 같은 단계에서 동일한 하드웨어 자원을 동시에 사용하려고 할 때 발생하는 자원 충돌 문제이다.
- **예시**: 단일 메모리 통로를 가진 단순한 CPU에서, 한 명령어는 데이터를 메모리에서 읽어오려 하고(실행 단계) 다른 명령어는 다음 명령어를 인출(인출 단계)하려고 할 때 충돌이 발생할 수 있다.
- **해결책**: 이 문제는 주로 하드웨어 설계 단계에서 해결된다. 예를 들어, 명령어 인출과 데이터 접근을 위한 캐시나 통로를 분리하는 것(하버드 아키텍처)이 대표적인 해결 방안이다.